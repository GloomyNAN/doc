---
title: 《高性能MySQL第三版》读书笔记
date: 2018-11-06 13:37:18
tags:
---

# 第一章 MySQL架构与历史

示例代码下载：http://www.highperfmysql.com/

## 架构与连接

MySQL服务器逻辑架构图

{% asset_img 15414866461331.jpg%}

**MySQL认证：使用了安全套接字（SSL）的方式，还可以是用X.509证书认证；**

## 锁
 
 两种类型的锁通常被称为共享锁（shared lock）和排他锁（exclusive lock），也叫读锁（read lock）和写锁（write lock）。
 
 读锁是共享的，互相不阻塞的；
 写锁是排他的，会阻塞其他的读锁和写锁；
 
## 锁粒度
 
 提高共享资源的并发性的方式是锁具有选择性，只锁定需要修改的部分数据，更理想的方式是针对会修改的数据片进行锁定，锁定的数据量越少，则系统的并发程度越高。

## 策略锁

在所得系统开销和数据的安全性之间寻找平衡，一般都是在表上 施加行级锁（row-level lock),并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能的提供更好的性能。

## 表锁（table lock）

Mysql中最基本的锁策略，并且是开销最小的锁策略，它会锁定整张表。

特定的场景中，表锁也可能有良好的性能，写锁也比读锁有更高的优先级，因此一个写锁请求可能会插入到读锁列表的前面（写锁可以插入到锁队列读锁的前面，读锁不能插入到写锁前面）。

## 行级锁（row lock)

行级锁可以最大程度支持并发处理（同时也带累了最大的所开销）。行级锁旨在存储引擎层实现，MySQL服务器层没有实现；

## 事务

事务就是一组原子性的SQL查询，或者说一个独立的工作单元。事务内的语句要么全部执行成功，要么全部执行失败。

>ACID表示原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。一个运行良好的事务处理系统，必须具备这些标准特征。
 
 - 原子性（atomicty）:被视为不可分割的最小单元；
 - 一致性（consistency）:数据库总是从一个一致性的状态转换到另一个一致性的状态；
 - 隔离性（isolation）: 通常是在修改最终提交之前对其他事务是不可见的；
 - 持久性（durability）:一旦提交，修改永久保存，即使系统崩溃也不会丢失。

## 隔离级别

MySQL定义了四中隔离级别

### READ UNCOMMITTED(未提交读) 

修改未提交，对其他的事务也是可见的，可以读取未提交的数据，成为賍读（Dirty Read）。

会导致很多问题、性能比其他级别好很多，除非非常必要，一般很少使用。

### READ COMMITTED（提交读）

大多数数据库系统默认的隔离级别都是READ COMMITTED，但是MySQL不是。

这个级别的事务在提交前，对其他事物不可见，有时候也叫做不和重复读（noorepeatable read),因为两次查询，可能到的不一样的结果。

### REPEATABLE READ(可重复读)

REPEATABLE READ解决了脏读的问题，保证同一个事务多次读取结果一致，但是理论上无法解决幻读（Phantim Read）的问题。

幻读：指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题 。

### SERIALIZABLE（可串行化）

SERIALIZABLE 是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE 会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁征用问题。
实际应用很少到这个级别隔离，只有非常取消确保数据的一致性，并可以接受没有并行的情况下才可以。

### 四种隔离比较

{% asset_img 15414934231875.jpg%}

### 死锁

多个事务在统一资源上相互占用，请求锁定对方资源导致恶性循环。

导致死锁：

1. 当多个事务以不同的顺序锁定资源时；
2. 多个事务同事锁定一个资源时；

> 为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如InnoDB存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。
> 还有一种解决方式，就是当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好。InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）。 

死锁发生后，只有部分或完全回滚一中一个事务才能打破死锁，重新执行因死锁回滚的事务。

### 事务日志

&nbsp;&nbsp;&nbsp;&nbsp;事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。

&nbsp;&nbsp;&nbsp;&nbsp;如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具体的恢复方式则视存储引擎而定。”

### MySQL中的事务

支持引擎：

- 官方：InnoDB和NDB Cluster
- 第三方：XtraDb和PBXT

### 自动提交（AutoCOMMIT）

```mysql
SHOW VARIABLES LIKE 'AUTOCOMMIT';
-- 设置启用
SET AUTOCOMMIT = 1;
```

### 设定隔离级别

    SET TRANSACTION ISOLATION LEVEL

新的隔离级别会在下一个事务开始时生效；

### 隐式和显式锁定

InnoDB采用两阶段所订协议（two-phase locking protocol）,事务中随时执行行锁，只有COMMIT或ROLLBACK才会释放，并且所有锁是同一时刻释放，InnoDB会根据隔离级别在需要的时候自动加锁；

InnoDB显示锁定

```SQL
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE
```

MySQL也支持LOCK TABLES 和UNLOCK TABLES 语句，这是在服务器层实现的，和存储引擎无关。它们有自己的用途，但并不能替代事务处理。如果应用需要用到事务，还是应该选择事务型存储引擎。

> LOCK TABLES 和事务之间相互影响的话，情况会变得非常复杂，在某些MySQL版本中甚至会产生无法预料的结果。因此，本书建议，除了事务中禁用了AUTOCOMMIT ，可以使用LOCK TABLES 之外，其他任何时候都不要显式地执行LOCK TABLES ，不管使用的是什么存储引擎。

### 多版本并发控制MVCC

**典型的有乐观（optimistic）并发控制和悲观（pessimistic）并发控制**

行级锁一个变种，开销更低，数据库大都实现了非阻塞的读操作，写操作也只锁定必要的行。

### InnoDB的MVCC如何工作

InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。下面看一下在REPEATABLE READ 隔离级别下，MVCC具体是如何操作的。

**SELECT**

InnoDB会根据以下两个条件检查每行记录：

1. InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
只有符合上述两个条件的记录，才能返回作为查询结果。

**INSERT**

InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

**DELETE**

InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

**UPDATE**

InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。

保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。

MVCC只在REPEATABLE READ 和READ COMMITTED 两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容 (4) ，因为READ UNCOMMITTED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE 则会对所有读取的行都加锁。

### MySQL的存储引擎

MySQL每个schema目录下创建一个和表同名的`.frm`文件表的定义。

